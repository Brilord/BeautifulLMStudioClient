<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover" />
  <title>LM Studio Chat · Modular</title>
  <!-- Fonts & libs -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- MathJax for LaTeX -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$','$'], ['\\(','\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true, packages: {'[+]': ['noerrors', 'noundefined']} },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'], ignoreHtmlClass: 'tex2jax_ignore', processHtmlClass: 'tex2jax_process' },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

  <style>
  /* =========================================================================
     LM Studio Chat — Modular Single File (with persistence)
     STYLE SHEET (DOCUMENTED) — NO BLUR EFFECTS
     ========================================================================= */

  /* THEME TOKENS */
  :root, :root[data-theme="light"] {
    --background-color: #f5f7fa;
    --text-color: #0f141b;
    --input-background: #e9edf3;

    --user-message-color: #dbe3ed;
    --assistant-message-color: #eef2f7;

    --button-color: #2b85ff;
    --accent-color: #7cc0ff;

    --border-radius: 12px;
    --transition-speed: 0.25s;
    --shadow: 0 2px 10px rgba(15, 20, 27, 0.12);
    --border-color: rgba(15, 20, 27, 0.15);
    --muted-text: #4a5562;
    --surface-tint: rgba(43, 133, 255, 0.06);

    --dim-amount: 0.25;
  }
  :root[data-theme="dark"] {
    --background-color: #0e1116;
    --text-color: #e6e8eb;
    --input-background: #161b22;

    --user-message-color: #1f242d;
    --assistant-message-color: #151a21;

    --button-color: #2b85ff;
    --accent-color: #7cc0ff;

    --border-radius: 12px;
    --transition-speed: 0.25s;
    --shadow: 0 8px 24px rgba(0,0,0,0.35);
    --border-color: rgba(255,255,255,0.08);
    --muted-text: #b6c0cc;
    --surface-tint: rgba(124, 192, 255, 0.08);

    --dim-amount: 0.38;
  }
  @media (prefers-color-scheme: dark) {
    :root:not([data-theme]) { color-scheme: dark; }
  }

  /* GLOBAL */
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; }
  body {
    background: var(--background-color);
    color: var(--text-color);
    font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    line-height: 1.45;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  a { color: var(--accent-color); text-decoration: none; }
  a:hover { text-decoration: underline; }

  /* BACKGROUND LAYERS */
  #bg-layer {
    position: fixed; inset: 0; z-index: -2;
    background-position: center;
    background-repeat: no-repeat;
    background-size: cover;
    transition: opacity var(--transition-speed) ease;
  }
  #bg-dim {
    position: fixed; inset: 0; z-index: -1;
    background: rgba(0, 0, 0, calc(var(--dim-amount)));
    pointer-events: none;
  }

  /* APP LAYOUT */
  #app { display: flex; flex-direction: column; height: 100dvh; }

  /* HEADER */
  #server-url-container {
    padding: 0.5rem env(safe-area-inset-right) 0.5rem env(safe-area-inset-left);
    background: color-mix(in oklab, var(--input-background) 92%, transparent);
    display: grid; gap: 0.5rem; align-items: center;
    grid-template-columns: auto 1fr auto auto auto auto auto auto auto;
    border-bottom: 1px solid var(--border-color);
    box-shadow: var(--shadow);
  }
  #mobile-menu-button { display: none; }

  #server-url, #model-select {
    min-width: 0;
    padding: 0.65rem 0.75rem;
    font-size: 0.95rem;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: var(--background-color);
    color: var(--text-color);
  }
  #model-select { width: min(42vw, 210px); }

  .icon-btn {
    display: inline-flex; align-items: center; justify-content: center;
    width: 40px; height: 40px; border-radius: 10px; cursor: pointer;
    background: var(--button-color); color: var(--text-color); border: none;
    transition: transform var(--transition-speed), background var(--transition-speed);
  }
  .icon-btn:hover { background: var(--accent-color); transform: translateY(-1px); }
  .icon-btn:active { transform: translateY(0); }

  #connect-button {
    padding: 0 0.9rem; min-width: 44px; height: 40px;
    border-radius: 10px; border: none; background: var(--button-color);
    color: var(--text-color); font-weight: 600; cursor: pointer;
  }

  #connection-status {
    text-align: center; padding: 0.4rem 0.6rem; font-size: 0.85rem;
    background: color-mix(in oklab, var(--input-background) 80%, transparent);
    color: var(--muted-text);
    border-bottom: 1px solid var(--border-color);
  }

  /* MAIN GRID */
  #main-content { display: grid; grid-template-columns: 280px 1fr; min-height: 0; flex: 1; }

  /* SIDEBAR */
  #chat-sidebar {
    background: color-mix(in oklab, var(--input-background) 96%, transparent);
    border-right: 1px solid var(--border-color);
    position: relative; overflow: hidden;
  }
  #toggle-sidebar { position: absolute; top: 10px; right: 10px; z-index: 2; }

  .sidebar-content { padding: 0.85rem; height: 100%; display: flex; flex-direction: column; gap: 0.7rem; }
  #chat-sidebar-header { display: flex; justify-content: space-between; align-items: center; font-weight: 700; }
  #new-chat-button {
    width: 100%; padding: 0.6rem 0.75rem; border: none; border-radius: 10px;
    font-weight: 600; background: var(--button-color); color: var(--text-color); cursor: pointer;
  }
  #chat-list { list-style: none; margin: 0; padding: 0; overflow-y: auto; }
  #chat-list li {
    padding: 0.6rem 0.65rem; border-radius: 10px; margin-bottom: 0.45rem; cursor: pointer;
    background: var(--background-color); border: 1px solid var(--border-color);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.92rem;
  }
  #chat-list li:hover { background: var(--input-background); }
  #chat-list li.active {
    background: var(--button-color); color: var(--text-color); border-color: transparent; font-weight: 700;
  }

  /* CHAT AREA */
  #chat-section { display: flex; flex-direction: column; min-height: 0; padding: 0.75rem; gap: 0.75rem; }
  #chat-container {
    flex: 1; overflow-y: auto; padding: 0.75rem; display: flex; flex-direction: column; gap: 0.75rem;
    background: color-mix(in oklab, var(--surface-tint) 70%, transparent);
    border: 1px solid var(--border-color); border-radius: var(--border-radius);
  }
  .message {
    max-width: 86%; padding: 0.85rem 1rem; border-radius: var(--border-radius);
    word-wrap: break-word;
    font-size: clamp(0.95rem, 0.95rem + 0.1vw, 1.02rem); line-height: 1.6;

    background: color-mix(in oklab, var(--assistant-message-color) 80%, transparent);
    border: 1px solid color-mix(in oklab, var(--text-color) 18%, transparent);
    box-shadow: 0 6px 20px rgba(0,0,0,0.28), inset 0 1px 0 rgba(255,255,255,0.05);

    position: relative; animation: fadeIn 0.25s ease both;
  }
  .user-message {
    align-self: flex-end;
    background: color-mix(in oklab, var(--user-message-color) 88%, transparent);
    border: 1px solid color-mix(in oklab, var(--text-color) 24%, transparent);
  }
  .assistant-message { align-self: flex-start; }

  .message-header { font-weight: 700; margin-bottom: 0.25rem; font-size: 0.85rem; }
  .message-model, .message-metrics { font-size: 0.76rem; color: var(--muted-text); }
  .message-content { margin-top: 0.2rem; text-shadow: 0 0 1px rgba(0,0,0,0.25); }

  .message-content pre {
    background: color-mix(in oklab, #0b0f14 85%, var(--background-color));
    color: #d7dde4; padding: 0.85rem; overflow-x: auto; border-radius: 10px; border: 1px solid var(--border-color);
  }
  .message-content code {
    background: rgba(15,20,27,0.14); padding: 0.15em 0.35em; border-radius: 4px;
  }
  .copy-btn {
    position: absolute; top: 6px; right: 6px; border: none; border-radius: 8px; cursor: pointer;
    font-size: 0.74rem; padding: 3px 9px; opacity: 0.40; background: var(--accent-color); color: var(--text-color);
  }

  /* INPUT BAR */
  #input-container {
    position: sticky; bottom: 0; padding: 0.5rem calc(0.5rem + env(safe-area-inset-right)) calc(0.5rem + env(safe-area-inset-bottom)) calc(0.5rem + env(safe-area-inset-left));
    display: grid; grid-template-columns: auto 1fr auto; gap: 0.5rem; align-items: center;
    background: color-mix(in oklab, var(--input-background) 94%, transparent);
    border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow);
  }
  #upload-button, #send-button, #bg-pick-button, #mobile-menu-button, #export-chats, #import-chats, #clear-chats {
    width: 44px; height: 44px; border-radius: 12px;
  }
  #user-input {
    min-height: 44px; padding: 0.7rem 0.8rem; border-radius: 12px;
    border: 1px solid var(--border-color);
    background: var(--background-color); color: var(--text-color); font-size: 1rem;
  }
  #user-input::placeholder { color: color-mix(in oklab, var(--muted-text) 70%, transparent); }
  #image-preview { display: none; max-width: 54px; }

  /* MOBILE */
  @media (max-width: 768px) {
    #main-content { grid-template-columns: 1fr; }
    #mobile-menu-button { display: inline-flex; }
    #toggle-sidebar { display: none; }

    #chat-sidebar {
      position: fixed; top: 0; left: 0; bottom: 0; width: min(82vw, 360px); max-width: 90vw;
      background: color-mix(in oklab, var(--input-background) 30%, transparent);
      border-right: 1px solid var(--border-color);
      transform: translateX(-102%); transition: transform var(--transition-speed) ease; z-index: 60;
    }
    #chat-sidebar.open { transform: translateX(0); }

    #sidebar-backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0; pointer-events: none; transition: opacity var(--transition-speed) ease; z-index: 55;
    }
    #sidebar-backdrop.show { opacity: 1; pointer-events: auto; }

    .message { background: color-mix(in oklab, var(--assistant-message-color) 28%, transparent); }
    .user-message { background: color-mix(in oklab, var(--user-message-color) 33%, transparent); }
  }

  /* TINY DEVICES */
  @media (max-width: 420px) {
    #server-url { font-size: 0.9rem; }
    #model-select { display: none; }
    #connect-button { height: 40px; padding: 0 0.75rem; }
  }

  /* MICRO INTERACTIONS */
  @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

  *::-webkit-scrollbar { width: 10px; height: 10px; }
  *::-webkit-scrollbar-thumb {
    background: color-mix(in oklab, var(--accent-color) 35%, #0000);
    border-radius: 10px; border: 2px solid transparent; background-clip: padding-box;
  }
  *::-webkit-scrollbar-track { background: transparent; }

  /* CONTEXT MENU */
  #context-menu{
    position: absolute;
    display: none;
    z-index: 3000;
    background: var(--background-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 0.5rem 0.75rem;
    box-shadow: var(--shadow);
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
  }
  #context-menu:hover{ background: var(--input-background); }
  </style>
</head>
<body>
  <!-- Background layers -->
  <div id="bg-layer" aria-hidden="true"></div>
  <div id="bg-dim" aria-hidden="true"></div>

  <div id="app">
    <!-- Header -->
    <div id="server-url-container">
      <button id="mobile-menu-button" class="icon-btn" title="Chats"><i class="fas fa-bars"></i></button>
      <input type="text" id="server-url" placeholder="Enter LM Studio server address" />
      <select id="model-select" disabled><option value="">Select a model</option></select>

      <!-- Background control -->
      <button id="bg-pick-button" class="icon-btn" title="Set background"><i class="fas fa-image"></i></button>
      <input type="file" id="bg-upload" accept="image/*" style="display:none;" />

      <!-- Connect -->
      <button id="connect-button" title="Connect"><i class="fas fa-plug"></i></button>

      <!-- Persistence controls -->
      <button id="export-chats" class="icon-btn" title="Export chats"><i class="fas fa-download"></i></button>
      <button id="import-chats" class="icon-btn" title="Import chats"><i class="fas fa-upload"></i></button>
      <button id="clear-chats"  class="icon-btn" title="Clear all chats"><i class="fas fa-trash"></i></button>
      <input type="file" id="import-file" accept="application/json" style="display:none;" />
    </div>
    <div id="connection-status">Disconnected</div>

    <div id="main-content">
      <!-- Sidebar -->
      <aside id="chat-sidebar">
        <button id="toggle-sidebar" class="icon-btn" title="Collapse sidebar"><i class="fas fa-bars"></i></button>
        <div class="sidebar-content">
          <div id="chat-sidebar-header"><span>Chats</span></div>
          <button id="new-chat-button"><i class="fas fa-plus"></i> New Chat</button>
          <ul id="chat-list"></ul>
        </div>
      </aside>

      <!-- Chat -->
      <section id="chat-section">
        <div id="chat-container"></div>
        <div id="input-container">
          <button id="upload-button" class="icon-btn" title="Attach image"><i class="fas fa-paperclip"></i></button>
          <input type="file" id="image-upload" accept="image/*" style="display:none;" />
          <div id="image-preview"></div>
          <input type="text" id="user-input" placeholder="Type a message..." disabled />
          <button id="send-button" class="icon-btn" title="Send" disabled><i class="fas fa-paper-plane"></i></button>
        </div>
      </section>
    </div>
  </div>

  <!-- Backdrop for mobile drawer -->
  <div id="sidebar-backdrop"></div>

  <!-- Context menu -->
  <div id="context-menu">Delete Chat</div>

  <!-- ========================= JS (ES Modules, single file) ========================= -->
  <script type="module">
    /*
      ARCHITECTURE OVERVIEW
      ├── Core: Events, Utils, Storage
      ├── State: reactive app state (single source of truth)
      ├── Services: BackgroundService, LMStudioAPI, Health
      ├── UI Components: Header, Sidebar, ChatView, InputBar
      └── AppController: wires everything together
    */

    // ================= Core: Events (simple pub-sub) =================
    const Events = (() => {
      const topics = new Map();
      return {
        on(topic, handler) {
          if (!topics.has(topic)) topics.set(topic, new Set());
          topics.get(topic).add(handler);
          return () => topics.get(topic)?.delete(handler);
        },
        emit(topic, payload) { topics.get(topic)?.forEach(h => { try { h(payload); } catch (e) { console.error(e); } }); },
      };
    })();

    // ================= Core: Utils =================
    const Utils = {
      debounce(fn, ms = 250) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; },
      clamp(n, min, max) { return Math.max(min, Math.min(max, n)); },
      uuid() { return Math.random().toString(36).slice(2) + Date.now().toString(36); },
      highlight(container) { container.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block)); },
      async typeset(el) { if (window.MathJax) { try { await MathJax.typesetPromise([el]); } catch (e) { console.warn('MathJax:', e); } } },
      copyButtonForPre(pre) {
        if (pre.querySelector('.copy-btn')) return;
        pre.style.position = 'relative';
        const button = document.createElement('button');
        button.className = 'copy-btn';
        button.innerHTML = '<i class="fas fa-copy"></i> Copy';
        button.addEventListener('click', () => {
          const codeText = pre.querySelector('code')?.innerText || '';
          navigator.clipboard.writeText(codeText).then(() => { button.innerText = 'Copied!'; setTimeout(() => (button.innerHTML = '<i class="fas fa-copy"></i> Copy'), 1400); });
        });
        pre.appendChild(button);
      },
      attachCopyButtons(container) { container.querySelectorAll('pre').forEach(Utils.copyButtonForPre); },
      deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
    };

    // ================= Core: Storage =================
    const Storage = (() => {
      const K = {
        serverUrl: 'lmstudio.serverUrl',
        recentServers: 'lmstudio.recentServers',
        bgImage: 'lmstudio.bgImage',
        bgDim: 'lmstudio.bgDim',
        chats: 'lmstudio.chats',
        currentChatId: 'lmstudio.currentChatId'
      };
      const safeGet = (k, def = null) => { try { const v = localStorage.getItem(k); return v ?? def; } catch { return def; } };
      const safeSet = (k, v) => { try { localStorage.setItem(k, v); } catch {} };
      const jsonGet = (k, def = null) => { try { const raw = localStorage.getItem(k); return raw ? JSON.parse(raw) : def; } catch { return def; } };
      const jsonSet = (k, obj) => { try { localStorage.setItem(k, JSON.stringify(obj)); } catch {} };

      return {
        K,
        getServerUrl() { return safeGet(K.serverUrl, ''); },
        setServerUrl(url) {
          safeSet(K.serverUrl, url);
          const list = jsonGet(K.recentServers, []);
          const next = [url, ...list.filter(x => x !== url)].slice(0, 5);
          jsonSet(K.recentServers, next);
        },
        getBgImage() { return safeGet(K.bgImage, ''); },
        setBgImage(dataUrl) { safeSet(K.bgImage, dataUrl); },
        clearBgImage() { try { localStorage.removeItem(K.bgImage); } catch {} },
        getBgDim() { const v = parseFloat(safeGet(K.bgDim, '')); return Number.isFinite(v) ? v : null; },
        setBgDim(v) { safeSet(K.bgDim, String(v)); },

        saveChats(chats) { jsonSet(K.chats, chats); },
        loadChats() { return jsonGet(K.chats, []); },
        saveCurrentChatId(id) { safeSet(K.currentChatId, String(id || '')); },
        loadCurrentChatId() { return safeGet(K.currentChatId, ''); },

        exportChats() {
          return JSON.stringify(this.loadChats(), null, 2);
        },
        importChats(json) {
          const data = JSON.parse(json);
          if (!Array.isArray(data)) throw new Error('Invalid chat dump: expected an array.');
          this.saveChats(data);
        },
        clearChats() {
          try { localStorage.removeItem(K.chats); } catch {}
          try { localStorage.removeItem(K.currentChatId); } catch {}
        },
      };
    })();

    // ================= State (single source of truth) =================
    const State = (() => {
      const state = {
        isConnected: false,
        currentModel: '',
        serverUrl: Storage.getServerUrl() || '',
        pendingImage: null,
        chats: Storage.loadChats(),
        currentChatId: Storage.loadCurrentChatId() || null,
      };

      const persist = () => {
        const sanitized = state.chats.map(chat => ({
          id: chat.id,
          name: chat.name,
          messages: (chat.messages || []).map(m => {
            const copy = { ...m };
            if (typeof copy.content === 'string') {
              copy.content = copy.content.replace(/<img[^>]+src="data:image[^"]+"[^>]*>/gi, '[Image omitted]');
            }
            if (copy.isImage) copy.imageData = null;
            return copy;
          })
        }));
        Storage.saveChats(sanitized);
        Storage.saveCurrentChatId(state.currentChatId);
        Storage.setServerUrl(state.serverUrl);
      };

      const api = {
        get currentChat() { return state.chats.find(c => c.id === state.currentChatId) || null; },
        ensureChat() {
          if (!api.currentChat) api.createChat();
          return api.currentChat;
        },
        createChat(name) {
          const chat = { id: Utils.uuid(), name: name || `Conversation ${state.chats.length + 1}`, messages: [] };
          state.chats.push(chat); state.currentChatId = chat.id; persist();
          Events.emit('state:chats', state.chats); Events.emit('state:currentChat', chat);
          return chat;
        },
        deleteChat(id) {
          state.chats = state.chats.filter(c => c.id !== id);
          if (state.currentChatId === id) { state.currentChatId = state.chats[0]?.id || null; }
          persist(); Events.emit('state:chats', state.chats); Events.emit('state:currentChat', api.currentChat);
        },
        clearAllChats() {
          state.chats = [];
          state.currentChatId = null;
          persist();
          Events.emit('state:chats', state.chats);
          Events.emit('state:currentChat', null);
        },
        replaceChats(newChats) {
          state.chats = Array.isArray(newChats) ? newChats : [];
          state.currentChatId = state.chats[0]?.id || null;
          persist();
          Events.emit('state:chats', state.chats);
          Events.emit('state:currentChat', api.currentChat);
        },
        renameCurrentChatIfDefault(snippet) {
          const chat = api.currentChat; if (!chat) return;
          if (/^Conversation\s\d+/.test(chat.name) || chat.name.startsWith('Conversation ')) {
            chat.name = snippet ? `Conversation: ${snippet}...` : chat.name;
            persist(); Events.emit('state:chats', state.chats);
          }
        },
        addMessage({ content, isUser, metrics = null, isImage = false, imageData = null, text = '' }) {
          const chat = api.ensureChat();
          chat.messages.push({
            id: Utils.uuid(),
            content,
            isUser,
            metrics,
            isImage,
            imageData,
            text,
            ts: Date.now(),
          });
          persist();
          Events.emit('chat:messageAdded', { chatId: chat.id, message: chat.messages[chat.messages.length - 1] });
        },
        setConnection({ connected, model }) {
          state.isConnected = connected; if (typeof model === 'string') state.currentModel = model;
          Events.emit('state:connection', { connected, model: state.currentModel }); persist();
        },
        setServerUrl(url) { state.serverUrl = url; persist(); Events.emit('state:serverUrl', url); },
        setModel(model) { state.currentModel = model; Events.emit('state:model', model); persist(); },
        setPendingImage(dataUrl) { state.pendingImage = dataUrl; Events.emit('state:pendingImage', dataUrl); },
        selectChat(id) { state.currentChatId = id; persist(); Events.emit('state:currentChat', api.currentChat); },
        get snapshot() { return JSON.parse(JSON.stringify(state)); },
      };
      return api;
    })();

    // ================= Services: Background =================
    const BackgroundService = (() => {
      const bgLayer = document.getElementById('bg-layer');
      function applyFromStorage() {
        const dataUrl = Storage.getBgImage();
        const dim = Storage.getBgDim();
        if (dataUrl) { bgLayer.style.backgroundImage = `url('${dataUrl}')`; document.body.style.backgroundColor = 'transparent'; }
        if (dim != null) document.documentElement.style.setProperty('--dim-amount', String(Utils.clamp(dim, 0, 0.8)));
      }
      function setFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = e => { const dataUrl = e.target.result; Storage.setBgImage(dataUrl); bgLayer.style.backgroundImage = `url('${dataUrl}')`; };
        reader.readAsDataURL(file);
      }
      function clear() { Storage.clearBgImage(); bgLayer.style.backgroundImage = ''; }
      function setDim(v) { const vv = Utils.clamp(parseFloat(v) || 0, 0, 0.8); Storage.setBgDim(vv); document.documentElement.style.setProperty('--dim-amount', String(vv)); }
      return { applyFromStorage, setFile, clear, setDim };
    })();

    // ================= Services: LM Studio API =================
    const LMStudioAPI = (() => {
      async function listModels(serverUrl) {
        const res = await fetch(`${serverUrl}/v1/models`);
        if (!res.ok) throw new Error('Failed to list models');
        return res.json();
      }
      async function eject(serverUrl, model) {
        try {
          await fetch(`${serverUrl}/v1/model/eject`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ model })
          });
        } catch (e) { console.warn('Eject error:', e); }
      }
      async function* streamChat({ serverUrl, model, messages, temperature = 0.7, max_tokens = -1 }) {
        const res = await fetch(`${serverUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model, messages, temperature, max_tokens, stream: true })
        });
        if (!res.ok || !res.body) throw new Error('Streaming failed');
        const reader = res.body.getReader(); const decoder = new TextDecoder();
        while (true) {
          const { value, done } = await reader.read(); if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n').filter(line => line.trim() !== '');
          for (const line of lines) {
            if (line.startsWith('data:')) {
              const dataStr = line.slice(5).trim();
              if (dataStr === '[DONE]') return;
              try {
                const parsed = JSON.parse(dataStr);
                const delta = parsed.choices?.[0]?.delta?.content;
                if (delta) yield delta;
              } catch (e) { console.warn('parse', e); }
            }
          }
        }
      }
      return { listModels, eject, streamChat };
    })();

    // ================= Services: Health (optional ping) =================
    const Health = (() => {
      async function ping() {
        const { serverUrl } = State.snapshot;
        if (!serverUrl) return false;
        try {
          const r = await fetch(`${serverUrl}/v1/models`, { method: 'GET' });
          return r.ok;
        } catch {
          return false;
        }
      }
      return { ping };
    })();

    // ================= UI: Header =================
    const Header = (() => {
      const els = {
        serverUrl: document.getElementById('server-url'),
        modelSelect: document.getElementById('model-select'),
        bgPickButton: document.getElementById('bg-pick-button'),
        bgUpload: document.getElementById('bg-upload'),
        connectButton: document.getElementById('connect-button'),
        status: document.getElementById('connection-status'),

        exportBtn: document.getElementById('export-chats'),
        importBtn: document.getElementById('import-chats'),
        clearBtn:  document.getElementById('clear-chats'),
        importFile:document.getElementById('import-file'),
      };

      let longPressTimer = null;

      function setStatus(text, ok) {
        els.status.textContent = text;
        els.status.style.color = ok ? 'var(--accent-color)' : '#f44336';
        els.connectButton.innerHTML = ok ? '<i class="fas fa-link"></i> Disconnect' : '<i class="fas fa-plug"></i> Connect';
        els.serverUrl.disabled = ok; Events.emit('ui:connectionControls', { enabled: ok });
      }

      function populateModels(data) {
        const list = data?.data || [];
        els.modelSelect.innerHTML = '';
        for (const m of list) {
          const opt = document.createElement('option');
          opt.value = m.id; opt.textContent = m.id;
          els.modelSelect.appendChild(opt);
        }
        els.modelSelect.disabled = list.length === 0;
        // Auto-select first model if present
        if (list.length > 0) els.modelSelect.selectedIndex = 0;
        State.setModel(els.modelSelect.value || '');
      }

      function attach() {
        // Restore URL
        const saved = State.snapshot.serverUrl || Storage.getServerUrl(); if (saved) els.serverUrl.value = saved;
        els.serverUrl.addEventListener('input', Utils.debounce(() => State.setServerUrl(els.serverUrl.value.trim()), 200));

        // Background controls
        els.bgPickButton.addEventListener('mousedown', () => {
          longPressTimer = setTimeout(() => {
            const choice = window.prompt('Background: type "pick" to choose, "clear" to remove, or a number (0–0.8) to set dim.');
            if (!choice) return;
            if (choice.toLowerCase() === 'clear') BackgroundService.clear();
            else if (choice.toLowerCase() === 'pick') els.bgUpload.click();
            else { const v = parseFloat(choice); if (!isNaN(v)) BackgroundService.setDim(v); }
          }, 500);
        });
        ['mouseup','mouseleave'].forEach(ev => els.bgPickButton.addEventListener(ev, () => clearTimeout(longPressTimer)));
        els.bgPickButton.addEventListener('click', () => els.bgUpload.click());
        els.bgUpload.addEventListener('change', () => { const f = els.bgUpload.files?.[0]; if (f) BackgroundService.setFile(f); els.bgUpload.value = ''; });

        // Connect / Disconnect
        els.connectButton.addEventListener('click', async () => {
          const { isConnected } = State.snapshot;
          if (isConnected) {
            State.setConnection({ connected: false });
            setStatus('Disconnected', false);
            Events.emit('network:disconnected');
            return;
          }
          const serverUrl = els.serverUrl.value.trim();
          if (!serverUrl) { setStatus('Please enter a valid server address', false); return; }
          try {
            setStatus('Connecting...', false);
            const data = await LMStudioAPI.listModels(serverUrl);
            State.setServerUrl(serverUrl);
            populateModels(data);
            State.setConnection({ connected: true });
            setStatus('Connected', true);
            Events.emit('network:connected', { serverUrl });
          } catch (e) {
            console.error(e); setStatus('Failed to connect', false);
            alert('Unable to connect to LM Studio server');
          }
        });

        // Model switching
        els.modelSelect.addEventListener('change', async (e) => {
          const newModel = e.target.value; const { serverUrl, currentModel } = State.snapshot;
          if (currentModel && currentModel !== newModel) await LMStudioAPI.eject(serverUrl, currentModel);
          State.setModel(newModel);
        });

        // Export / Import / Clear
        els.exportBtn?.addEventListener('click', () => {
          const blob = new Blob([Storage.exportChats()], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `lmstudio-chats-${new Date().toISOString().slice(0,19)}.json`;
          a.click();
          URL.revokeObjectURL(a.href);
        });

        els.importBtn?.addEventListener('click', () => els.importFile?.click());
        els.importFile?.addEventListener('change', async () => {
          const f = els.importFile.files?.[0];
          if (!f) return;
          try {
            const text = await f.text();
            Storage.importChats(text);
            const chats = Storage.loadChats();
            State.replaceChats(chats);
            alert('Chats imported.');
          } catch (e) {
            console.error(e);
            alert('Import failed: invalid JSON or structure.');
          } finally {
            els.importFile.value = '';
          }
        });

        els.clearBtn?.addEventListener('click', () => {
          if (!confirm('Delete all saved chats? This cannot be undone.')) return;
          Storage.clearChats();
          State.clearAllChats();
        });

        // React to connection state changes
        Events.on('state:connection', ({ connected }) => { setStatus(connected ? 'Connected' : 'Disconnected', connected); });
      }

      return { attach, setStatus };
    })();

    // ================= UI: Sidebar (chat list) =================
    const Sidebar = (() => {
      const els = {
        list: document.getElementById('chat-list'),
        newChat: document.getElementById('new-chat-button'),
        toggle: document.getElementById('toggle-sidebar'),
        sidebar: document.getElementById('chat-sidebar'),
        contextMenu: document.getElementById('context-menu')
      };

      function render(chats, currentId) {
        els.list.innerHTML = '';
        for (const c of chats) {
          const li = document.createElement('li');
          li.textContent = c.name; li.dataset.chatId = c.id; if (c.id === currentId) li.classList.add('active');
          li.addEventListener('click', () => State.selectChat(c.id));
          li.addEventListener('contextmenu', (e) => { e.preventDefault(); showContextMenu(e.pageX, e.pageY, c.id); });
          els.list.appendChild(li);
        }
      }

      function showContextMenu(x, y, chatId) {
        const m = els.contextMenu;

        // Prepare & measure
        m.style.display = 'block';
        m.style.visibility = 'hidden';
        const w = m.offsetWidth || 160;
        const h = m.offsetHeight || 40;

        // Clamp within viewport
        const margin = 8;
        const nx = Math.min(x, window.innerWidth  - w - margin);
        const ny = Math.min(y, window.innerHeight - h - margin);

        // Place and show
        m.style.left = nx + 'px';
        m.style.top  = ny + 'px';
        m.style.visibility = 'visible';

        m.onclick = async (e) => {
          e.stopPropagation();
          State.deleteChat(chatId);
          // Optional server health ping after delete
          const ok = await Health.ping();
          if (!ok) Header.setStatus('Connected (server did not respond to ping)', false);
          hideContextMenu();
        };
      }
      function hideContextMenu() { els.contextMenu.style.display = 'none'; els.contextMenu.style.visibility = 'hidden'; }

      function bind() {
        els.newChat.addEventListener('click', async () => {
          State.createChat();
          // Optional server health ping after create
          const ok = await Health.ping();
          if (!ok) Header.setStatus('Connected (server did not respond to ping)', false);
        });
        els.toggle.addEventListener('click', () => els.sidebar.classList.toggle('collapsed'));

        // Mobile off-canvas controls
        const mobileBtn = document.getElementById('mobile-menu-button');
        const backdrop  = document.getElementById('sidebar-backdrop');

        const open = () => {
          els.sidebar.classList.add('open');
          backdrop?.classList.add('show');
          document.body.style.overflow = 'hidden';
        };
        const close = () => {
          els.sidebar.classList.remove('open');
          backdrop?.classList.remove('show');
          document.body.style.overflow = '';
        };

        mobileBtn?.addEventListener('click', open);
        backdrop?.addEventListener('click', close);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });

        const mq = window.matchMedia('(min-width: 769px)');
        if (mq.addEventListener) mq.addEventListener('change', () => { if (mq.matches) close(); });
        else mq.onchange = () => { if (mq.matches) close(); };

        const refresh = () => render(State.snapshot.chats, State.snapshot.currentChatId);
        Events.on('state:chats', refresh); Events.on('state:currentChat', refresh);
        refresh();

        document.addEventListener('click', () => hideContextMenu());
        window.addEventListener('scroll', hideContextMenu, { passive: true });
        window.addEventListener('resize', hideContextMenu);
      }
      return { bind };
    })();

    // ================= UI: ChatView (append-only streaming safe) =================
    const ChatView = (() => {
      const container = document.getElementById('chat-container');
      let liveStreamEl = null;

      function messageHtml(msg, model) {
        const { isUser, content } = msg;
        const wrapper = document.createElement('div');
        wrapper.classList.add('message', isUser ? 'user-message' : 'assistant-message');

        const header = document.createElement('div');
        header.className = 'message-header';
        header.textContent = isUser ? 'You' : 'Assistant';
        wrapper.appendChild(header);

        if (!isUser && model) {
          const m = document.createElement('div');
          m.className = 'message-model';
          m.textContent = model;
          wrapper.appendChild(m);
        }

        const meta = document.createElement('div');
        meta.className = 'message-metrics';
        const when = new Date(msg.ts || Date.now()).toLocaleString();
        meta.textContent = when;
        wrapper.appendChild(meta);

        const body = document.createElement('div');
        body.className = 'message-content';
        body.innerHTML = marked.parse(content || '');
        wrapper.appendChild(body);

        return { wrapper, body };
      }

      function appendMessage(msg) {
        const { wrapper } = messageHtml(msg, !msg.isUser ? State.snapshot.currentModel : '');
        container.appendChild(wrapper);
        Utils.highlight(wrapper); Utils.attachCopyButtons(wrapper); Utils.typeset(wrapper);
        container.scrollTop = container.scrollHeight;
      }

      function renderChat(chat) {
        container.innerHTML = '';
        if (!chat) return;
        for (const msg of chat.messages) appendMessage(msg);
        container.scrollTop = container.scrollHeight;
      }

      function addStreamingAssistantMessage() {
        const shell = document.createElement('div');
        shell.className = 'message assistant-message';
        shell.innerHTML = `
          <div class="message-header">Assistant</div>
          <div class="message-model">${State.snapshot.currentModel || ''}</div>
          <div class="message-metrics">${new Date().toLocaleString()}</div>
          <div class="message-content"></div>
        `;
        container.appendChild(shell);
        container.scrollTop = container.scrollHeight;
        liveStreamEl = shell;
        return {
          body: shell.querySelector('.message-content'),
          discard() { if (liveStreamEl) { liveStreamEl.remove(); liveStreamEl = null; } }
        };
      }

      function updateStreaming(targetBody, text) {
        targetBody.innerHTML = marked.parse(text);
        Utils.highlight(targetBody.parentElement); Utils.attachCopyButtons(targetBody.parentElement); Utils.typeset(targetBody.parentElement);
        container.scrollTop = container.scrollHeight;
      }

      function bind() {
        Events.on('state:currentChat', renderChat);
        Events.on('chat:messageAdded', ({ chatId, message }) => {
          if (State.snapshot.currentChatId !== chatId) return;
          appendMessage(message);
        });
        renderChat(State.snapshot.currentChat);
      }
      return { bind, addStreamingAssistantMessage, updateStreaming };
    })();

    // ================= UI: InputBar =================
    const InputBar = (() => {
      const els = {
        dropZone: document.getElementById('input-container'),
        uploadBtn: document.getElementById('upload-button'),
        file: document.getElementById('image-upload'),
        preview: document.getElementById('image-preview'),
        input: document.getElementById('user-input'),
        send: document.getElementById('send-button')
      };

      function setEnabled(yes) { els.input.disabled = !yes; els.send.disabled = !yes; }
      function showPendingImage(dataURL) {
        els.preview.innerHTML = `<img src="${dataURL}" style="max-width:100%; border-radius: var(--border-radius);" />`;
        els.preview.style.display = 'block';
      }
      function clearPendingPreview() { els.preview.innerHTML = ''; els.preview.style.display = 'none'; }

      async function handleImageFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const dataURL = await new Promise((resolve, reject) => {
          const r = new FileReader(); r.onload = e => resolve(e.target.result); r.onerror = reject; r.readAsDataURL(file);
        });
        State.setPendingImage(dataURL); showPendingImage(dataURL); els.input.focus();
      }

      async function handleTransferItems(dt) {
        if (!dt) return;
        if (dt.files && dt.files.length) {
          for (const f of dt.files) { if (f.type?.startsWith('image/')) { await handleImageFile(f); return; } }
        }
        if (dt.items && dt.items.length) {
          for (const it of dt.items) {
            if (it.kind === 'file' && it.type.startsWith('image/')) {
              const f = it.getAsFile(); if (f) { await handleImageFile(f); return; }
            }
          }
        }
        const url = dt.getData && (dt.getData('text/uri-list') || dt.getData('text/plain'));
        if (url && /^https?:\/\//i.test(url) && /\.(png|jpe?g|gif|webp|bmp|svg)(\?|#|$)/i.test(url)) {
          State.setPendingImage(url); showPendingImage(url); els.input.focus();
        }
      }

      function bind() {
        // Buttons & file input
        els.uploadBtn.addEventListener('click', () => els.file.click());
        els.file.addEventListener('change', () => { const f = els.file.files?.[0]; if (f) handleImageFile(f); els.file.value = ''; });

        // Paste & DnD
        els.input.addEventListener('paste', async (e) => {
          const dt = e.clipboardData; if (!dt) return;
          const hasImg = Array.from(dt.items || []).some(i => i.kind === 'file' && i.type.startsWith('image/'));
          if (hasImg) { e.preventDefault(); await handleTransferItems(dt); }
        });
        document.addEventListener('paste', async (e) => {
          if (document.activeElement !== els.input) {
            const dt = e.clipboardData; if (!dt) return;
            const hasImg = Array.from(dt.items || []).some(i => i.kind === 'file' && i.type.startsWith('image/'));
            if (hasImg) { e.preventDefault(); await handleTransferItems(dt); }
          }
        });
        ;['dragenter','dragover','dragleave','drop'].forEach(evt => {
          els.dropZone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); });
        });
        els.dropZone.addEventListener('dragenter', () => els.dropZone.classList.add('drop-hover'));
        els.dropZone.addEventListener('dragover',  () => els.dropZone.classList.add('drop-hover'));
        els.dropZone.addEventListener('dragleave', () => els.dropZone.classList.remove('drop-hover'));
        els.dropZone.addEventListener('drop', async (e) => { els.dropZone.classList.remove('drop-hover'); const dt = e.dataTransfer; await handleTransferItems(dt); });

        // Enable/disable with connection
        Events.on('ui:connectionControls', ({ enabled }) => setEnabled(enabled));
        setEnabled(false);
      }

      function getMessageAndMaybeImage() {
        const text = els.input.value.trim();
        const img = State.snapshot.pendingImage;
        if (!text && !img) return null;

        if (img) {
          State.addMessage({
            content: `<img src="${img}" style="max-width:100%; border-radius: var(--border-radius);" />`,
            isUser: true
          });
          State.addMessage({ content: text || "What's in this image?", isUser: true, isImage: true, imageData: img, text: text || '' });
          State.setPendingImage(null); clearPendingPreview(); els.input.value = '';
          return { kind: 'image', text: text || "What's in this image?", data: img };
        } else {
          State.addMessage({ content: text, isUser: true });
          els.input.value = '';
          return { kind: 'text', text };
        }
      }

      function focus() { els.input.focus(); }

      return { bind, getMessageAndMaybeImage, focus };
    })();

    // ================= App Controller =================
    const AppController = (() => {
      async function buildConversationHistory() {
        const chat = State.ensureChat();
        const hasImage = chat.messages.some(m => m.isImage);
        const systemPrompt = hasImage
          ? 'You are an AI assistant that analyzes images.'
          : 'You are an intelligent assistant. You always provide well-reasoned answers that are both correct and helpful.';
        const history = [{ role: 'system', content: systemPrompt }];
        for (const msg of chat.messages) {
          if (msg.isImage && msg.imageData) {
            history.push({
              role: msg.isUser ? 'user' : 'assistant',
              content: [
                { type: 'text', text: msg.text || "What's in this image?" },
                { type: 'image_url', image_url: { url: msg.imageData } }
              ]
            });
          } else {
            history.push({ role: msg.isUser ? 'user' : 'assistant', content: msg.content });
          }
        }
        return history;
      }

      function bindSend() {
        const sendBtn = document.getElementById('send-button');
        const input = document.getElementById('user-input');
        sendBtn.addEventListener('click', onSend);
        input.addEventListener('keypress', (e) => { if (e.key === 'Enter') onSend(); });
      }

      async function onSend() {
        // Guard: must be connected + have URL + have model
        const { serverUrl, currentModel, isConnected } = State.snapshot;
        if (!isConnected) {
          Header.setStatus('Disconnected', false);
          alert('Connect to the LM Studio server first.');
          return;
        }
        if (!serverUrl) {
          alert('Missing server URL.');
          return;
        }
        if (!currentModel) {
          alert('Pick a model before sending.');
          return;
        }

        const req = InputBar.getMessageAndMaybeImage();
        if (!req) return;

        // streaming shell (returns { body, discard })
        const stream = ChatView.addStreamingAssistantMessage();
        let acc = '';

        const messages = await buildConversationHistory();

        try {
          for await (const delta of LMStudioAPI.streamChat({ serverUrl, model: currentModel, messages })) {
            acc += delta; ChatView.updateStreaming(stream.body, acc);
          }
          // Remove ephemeral bubble first, then persist the final assistant message
          stream.discard();
          State.addMessage({ content: acc, isUser: false });
          State.renameCurrentChatIfDefault(acc.split(' ').slice(0, 7).join(' '));
        } catch (e) {
          console.error(e);
          stream.discard();
          State.addMessage({
            content: 'Send failed (connection kept). Check server URL, CORS, model, and try again.',
            isUser: false
          });
          // NOTE: do NOT auto-toggle to Disconnected here
        } finally {
          InputBar.focus();
        }
      }

      function init() {
        BackgroundService.applyFromStorage();

        // UI components
        Header.attach(); Sidebar.bind(); ChatView.bind(); InputBar.bind();

        // Initial chat if none
        if (!State.snapshot.currentChatId || !State.snapshot.chats.length) State.createChat();

        // Initial focus
        const urlInput = document.getElementById('server-url'); urlInput.focus();

        // Bind send
        bindSend();
      }

      return { init };
    })();

    // ================= Boot =================
    AppController.init();
  </script>
</body>
</html>
