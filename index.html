<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover" />
  <title>LM Studio Chat Â· Modular</title>
  <!-- Fonts & libs -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- MathJax for LaTeX -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$','$'], ['\\(','\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true, packages: {'[+]': ['noerrors', 'noundefined']} },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre'], ignoreHtmlClass: 'tex2jax_ignore', processHtmlClass: 'tex2jax_process' },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

  <style>
  /* =========================================================================
     LM Studio Chat â€” Modular Single File (with persistence)
     STYLE SHEET (DOCUMENTED) â€” MOBILE-OPTIMIZED + STREAMING FIXES
     ========================================================================= */

  /* THEME TOKENS */
  :root, :root[data-theme="light"] {
    --background-color: #f5f7fa;
    --text-color: #0f141b;
    --input-background: #e9edf3;

    --user-message-color: #dbe3ed;
    --assistant-message-color: #eef2f7;

    --button-color: #2b85ff;
    --accent-color: #7cc0ff;

    --border-radius: 12px;
    --transition-speed: 0.25s;
    --shadow: 0 2px 10px rgba(15, 20, 27, 0.12);
    --border-color: rgba(15, 20, 27, 0.15);
    --muted-text: #4a5562;
    --surface-tint: rgba(43, 133, 255, 0.06);

    --dim-amount: 0.25;
  }
  :root[data-theme="dark"] {
    --background-color: #0e1116;
    --text-color: #e6e8eb;
    --input-background: #161b22;

    --user-message-color: #1f242d;
    --assistant-message-color: #151a21;

    --button-color: #2b85ff;
    --accent-color: #7cc0ff;

    --border-radius: 12px;
    --transition-speed: 0.25s;
    --shadow: 0 8px 24px rgba(0,0,0,0.35);
    --border-color: rgba(255,255,255,0.08);
    --muted-text: #b6c0cc;
    --surface-tint: rgba(124, 192, 255, 0.08);

    --dim-amount: 0.38;
  }
  @media (prefers-color-scheme: dark) {
    :root:not([data-theme]) { color-scheme: dark; }
  }

  /* GLOBAL */
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; }
  body {
    background: var(--background-color);
    color: var(--text-color);
    font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    line-height: 1.45;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-size-adjust: 100%;
  }
  a { color: var(--accent-color); text-decoration: none; }
  a:hover { text-decoration: underline; }

  /* BACKGROUND LAYERS */
  #bg-layer {
    position: fixed; inset: 0; z-index: -2;
    background-position: center;
    background-repeat: no-repeat;
    background-size: cover;
    transition: opacity var(--transition-speed) ease;
  }
  #bg-dim {
    position: fixed; inset: 0; z-index: -1;
    background: rgba(0, 0, 0, calc(var(--dim-amount)));
    pointer-events: none;
  }

  /* APP LAYOUT */
  #app { display: flex; flex-direction: column; height: 100dvh; }

  /* HEADER */
  #server-url-container {
    padding: 0.5rem env(safe-area-inset-right) 0.5rem env(safe-area-inset-left);
    background: color-mix(in oklab, var(--input-background) 40%, transparent);
    display: grid; gap: 0.5rem; align-items: center;
    grid-template-columns: auto 1fr auto auto auto auto auto auto auto;
    border-bottom: 1px solid var(--border-color);
    box-shadow: var(--shadow);
    position: sticky; top: 0; z-index: 10;
  }
  #mobile-menu-button { display: none; }

  #server-url, #model-select {
    min-width: 0;
    padding: 0.65rem 0.75rem;
    font-size: 0.95rem;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: var(--background-color);
    color: var(--text-color);
  }
  #model-select { width: min(42vw, 210px); }

  .icon-btn {
    display: inline-flex; align-items: center; justify-content: center;
    width: 40px; height: 40px; border-radius: 10px; cursor: pointer;
    background: var(--button-color); color: var(--text-color); border: none;
    transition: transform var(--transition-speed), background var(--transition-speed);
    touch-action: manipulation;
  }
  .icon-btn:hover { background: var(--accent-color); transform: translateY(-1px); }
  .icon-btn:active { transform: translateY(0); }

  #connect-button {
    padding: 0 0.9rem; min-width: 44px; height: 40px;
    border-radius: 10px; border: none; background: var(--button-color);
    color: var(--text-color); font-weight: 600; cursor: pointer;
  }

  #connection-status {
    text-align: center; padding: 0.4rem 0.6rem; font-size: 0.85rem;
    background: color-mix(in oklab, var(--input-background) 80%, transparent);
    color: var(--muted-text);
    border-bottom: 1px solid var(--border-color);
  }

  /* !!! NEW: center banner */
  #header-banner{
    grid-column: 1 / -1;
    text-align: center;
    font-weight: 700;
    letter-spacing: .2px;
    opacity: .9;
    pointer-events: none;
    user-select: none;
    white-space: nowrap;
  }
  #header-banner.typing::after{
    content: 'â–Œ';
    display: inline-block;
    margin-left: 2px;
    animation: blink 1s steps(2, start) infinite;
  }
  @keyframes blink { 50% { opacity: 0; } }

  /* MAIN GRID */
  #main-content { display: grid; grid-template-columns: 280px 1fr; min-height: 0; flex: 1; }

  /* SIDEBAR */
  #chat-sidebar {
    background: color-mix(in oklab, var(--input-background) 96%, transparent);
    border-right: 1px solid var(--border-color);
    position: relative; overflow: hidden;
  }
  #toggle-sidebar { position: absolute; top: 10px; right: 10px; z-index: 2; }

  .sidebar-content { padding: 0.85rem; height: 100%; display: flex; flex-direction: column; gap: 0.7rem; }
  #chat-sidebar-header { display: flex; justify-content: space-between; align-items: center; font-weight: 700; }
  #new-chat-button {
    width: 100%; padding: 0.6rem 0.75rem; border: none; border-radius: 10px;
    font-weight: 600; background: var(--button-color); color: var(--text-color); cursor: pointer;
  }
  #chat-list { list-style: none; margin: 0; padding: 0; overflow-y: auto; }
  #chat-list li {
    padding: 0.6rem 0.65rem; border-radius: 10px; margin-bottom: 0.45rem; cursor: pointer;
    background: var(--background-color); border: 1px solid var(--border-color);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.92rem;
  }
  #chat-list li:hover { background: var(--input-background); }
  #chat-list li.active {
    background: var(--button-color); color: var(--text-color); border-color: transparent; font-weight: 700;
  }

  /* CHAT AREA */
  #chat-section { display: flex; flex-direction: column; min-height: 0; padding: 0.75rem; gap: 0.75rem; }
  #chat-container {
    flex: 1; overflow-y: auto; padding: 0.75rem; display: flex; flex-direction: column; gap: 0.75rem;
    background: color-mix(in oklab, var(--surface-tint) 70%, transparent);
    border: 1px solid var(--border-color); border-radius: var(--border-radius);
  }
  .message {
    max-width: 86%; padding: 0.85rem 1rem; border-radius: var(--border-radius);
    word-wrap: break-word;
    font-size: clamp(0.95rem, 0.95rem + 0.1vw, 1.02rem); line-height: 1.6;

    background: color-mix(in oklab, var(--assistant-message-color) 80%, transparent);
    border: 1px solid color-mix(in oklab, var(--text-color) 18%, transparent);
    box-shadow: 0 6px 20px rgba(0,0,0,0.28), inset 0 1px 0 rgba(255,255,255,0.05);

    position: relative; animation: fadeIn 0.25s ease both;
  }
  .user-message {
    align-self: flex-end;
    background: color-mix(in oklab, var(--user-message-color) 88%, transparent);
    border: 1px solid color-mix(in oklab, var(--text-color) 24%, transparent);
  }
  .assistant-message { align-self: flex-start; }

  .message-header { font-weight: 700; margin-bottom: 0.25rem; font-size: 0.85rem; }
  .message-model, .message-metrics { font-size: 0.76rem; color: var(--muted-text); }
  .message-content { margin-top: 0.2rem; text-shadow: 0 0 1px rgba(0,0,0,0.25); }

  .message-content pre {
    background: color-mix(in oklab, #0b0f14 85%, var(--background-color));
    color: #d7dde4; padding: 0.85rem; overflow-x: auto; border-radius: 10px; border: 1px solid var(--border-color);
  }
  .message-content code {
    background: rgba(15,20,27,0.14); padding: 0.15em 0.35em; border-radius: 4px;
  }
  .copy-btn {
    position: absolute; top: 6px; right: 6px; border: none; border-radius: 8px; cursor: pointer;
    font-size: 0.74rem; padding: 3px 9px; opacity: 0.40; background: var(--accent-color); color: var(--text-color);
  }

  /* INPUT BAR */
  #input-container {
    position: sticky; bottom: 0; padding: 0.5rem calc(0.5rem + env(safe-area-inset-right)) calc(0.5rem + env(safe-area-inset-bottom)) calc(0.5rem + env(safe-area-inset-left));
    display: grid; grid-template-columns: auto 1fr auto; gap: 0.5rem; align-items: center;
    background: color-mix(in oklab, var(--input-background) 94%, transparent);
    border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow);
  }
  #upload-button, #send-button, #bg-pick-button, #mobile-menu-button, #export-chats, #import-chats, #clear-chats {
    width: 44px; height: 44px; border-radius: 12px;
  }
  #user-input {
    min-height: 44px; padding: 0.7rem 0.8rem; border-radius: 12px;
    border: 1px solid var(--border-color);
    background: var(--background-color); color: var(--text-color); font-size: 16px; /* Prevent iOS zoom */
  }
  #user-input::placeholder { color: color-mix(in oklab, var(--muted-text) 70%, transparent); }
  #image-preview { display: none; max-width: 54px; }

  /* MOBILE */
  @media (max-width: 768px) {
    #main-content { grid-template-columns: 1fr; }
    #mobile-menu-button { display: inline-flex; }
    #toggle-sidebar { display: none; }

    #server-url-container {
      grid-template-columns: auto 1fr auto auto; /* menu, url, bg, connect */
    }
    #model-select, #export-chats, #import-chats, #clear-chats, #header-banner { display: none; }

    #chat-sidebar {
      position: fixed; top: 0; left: 0; bottom: 0; width: min(88vw, 360px); max-width: 90vw;
      background: color-mix(in oklab, var(--input-background) 30%, transparent);
      border-right: 1px solid var(--border-color);
      transform: translateX(-102%); transition: transform var(--transition-speed) ease; z-index: 60;
      backdrop-filter: none; /* ensure no blur */
    }
    #chat-sidebar.open { transform: translateX(0); }

    #sidebar-backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0; pointer-events: none; transition: opacity var(--transition-speed) ease; z-index: 55;
    }
    #sidebar-backdrop.show { opacity: 1; pointer-events: auto; }

    .message { background: color-mix(in oklab, var(--assistant-message-color) 28%, transparent); max-width: 92%; }
    .user-message { background: color-mix(in oklab, var(--user-message-color) 33%, transparent); }

    #chat-container { padding-bottom: 0.25rem; }
  }

  /* TINY DEVICES */
  @media (max-width: 420px) {
    #server-url { font-size: 0.9rem; }
    #connect-button { height: 40px; padding: 0 0.75rem; }
  }

  /* MICRO INTERACTIONS */
  @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

  *::-webkit-scrollbar { width: 10px; height: 10px; }
  *::-webkit-scrollbar-thumb {
    background: color-mix(in oklab, var(--accent-color) 35%, #0000);
    border-radius: 10px; border: 2px solid transparent; background-clip: padding-box;
  }
  *::-webkit-scrollbar-track { background: transparent; }

  /* CONTEXT MENU */
  #context-menu{
    position: absolute;
    display: none;
    z-index: 3000;
    background: var(--background-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 0.5rem 0.75rem;
    box-shadow: var(--shadow);
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
  }
  #context-menu:hover{ background: var(--input-background); }

  /* LOADING DOTS */
  .loading-dots { font-variant-numeric: tabular-nums; }
  .loading-dots::after {
    content: '';
    animation: dots 1.2s steps(4, end) infinite;
  }
  @keyframes dots { 0% { content: ' .'; } 25% { content: ' ..'; } 50% { content: ' ...'; } 75%, 100% { content: ' ....'; } }

  /* === Debug Panel (overlay) === */
  #debug-panel {
    position: fixed; inset: auto 12px 12px auto; width: min(520px, 92vw); max-height: 60vh;
    background: color-mix(in oklab, var(--input-background) 92%, transparent);
    color: var(--text-color); border: 1px solid var(--border-color);
    border-radius: 12px; box-shadow: var(--shadow); z-index: 9999; display: none; overflow: hidden;
  }
  #debug-panel.open { display: grid; grid-template-rows: auto auto 1fr; }
  #debug-panel-header { display:flex; align-items:center; gap:.5rem; padding:.5rem .75rem; font-weight:700; }
  #debug-panel-controls { display:flex; gap:.5rem; padding: .25rem .75rem .5rem; }
  #debug-panel-controls button {
    border: 1px solid var(--border-color); background: var(--background-color);
    border-radius: 8px; padding:.3rem .6rem; cursor:pointer;
  }
  #debug-log {
    font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    background: color-mix(in oklab, #0b0f14 85%, var(--background-color));
    color: #d7dde4; padding:.5rem; overflow:auto; white-space:pre-wrap;
  }
  </style>
</head>
<body>
  <!-- Background layers -->
  <div id="bg-layer" aria-hidden="true"></div>
  <div id="bg-dim" aria-hidden="true"></div>

  <div id="app">
    <!-- Header -->
    <div id="server-url-container">
      <button id="mobile-menu-button" class="icon-btn" title="Chats"><i class="fas fa-bars"></i></button>
      <input type="text" id="server-url" placeholder="Enter LM Studio server address" />
      <select id="model-select" disabled><option value="">Select a model</option></select>

      <!-- NEW center banner -->
      <div id="header-banner" aria-live="polite" title="Built with care">built by Brian Won</div>

      <!-- Background control -->
      <button id="bg-pick-button" class="icon-btn" title="Set background"><i class="fas fa-image"></i></button>
      <input type="file" id="bg-upload" accept="image/*" style="display:none;" />

      <!-- Connect -->
      <button id="connect-button" title="Connect"><i class="fas fa-plug"></i></button>

      <!-- Persistence controls (hidden on mobile) -->
      <button id="export-chats" class="icon-btn" title="Export chats"><i class="fas fa-download"></i></button>
      <button id="import-chats" class="icon-btn" title="Import chats"><i class="fas fa-upload"></i></button>
      <button id="clear-chats"  class="icon-btn" title="Clear all chats"><i class="fas fa-trash"></i></button>
      <input type="file" id="import-file" accept="application/json" style="display:none;" />
    </div>
    <div id="connection-status">Disconnected</div>

    <div id="main-content">
      <!-- Sidebar -->
      <aside id="chat-sidebar">
        <button id="toggle-sidebar" class="icon-btn" title="Collapse sidebar"><i class="fas fa-bars"></i></button>
        <div class="sidebar-content">
          <div id="chat-sidebar-header"><span>Chats</span></div>
          <button id="new-chat-button"><i class="fas fa-plus"></i> New Chat</button>
          <ul id="chat-list"></ul>
        </div>
      </aside>

      <!-- Chat -->
      <section id="chat-section">
        <div id="chat-container"></div>
        <div id="input-container">
          <button id="upload-button" class="icon-btn" title="Attach image"><i class="fas fa-paperclip"></i></button>
          <input type="file" id="image-upload" accept="image/*" style="display:none;" />
          <div id="image-preview"></div>
          <input type="text" id="user-input" placeholder="Type a message..." disabled />
          <button id="send-button" class="icon-btn" title="Send" disabled><i class="fas fa-paper-plane"></i></button>
        </div>
      </section>
    </div>
  </div>

  <!-- Backdrop for mobile drawer -->
  <div id="sidebar-backdrop"></div>

  <!-- Context menu -->
  <div id="context-menu">Delete Chat</div>

  <!-- ========================= JS (ES Modules, single file) ========================= -->
  <script type="module">
    /*
      ARCHITECTURE OVERVIEW (maintainable + instrumented)
      â”œâ”€â”€ Debug: Logger/Inspector (global, toggle with Ctrl+Alt+D or `)
      â”œâ”€â”€ Core: Events (pub/sub with auto-logging), Utils, Storage
      â”œâ”€â”€ State: reactive app state (single source of truth; persists to localStorage)
      â”œâ”€â”€ Services: BackgroundService, LMStudioAPI (with perf marks), Health
      â”œâ”€â”€ UI Components: Header, Sidebar, ChatView, InputBar
      â””â”€â”€ AppController: wires everything, streaming safe updates
    */

    // ================= Debug: Logger & Inspector =================
    const DEBUG = (() => {
      // Activation: ?debug=1 or localStorage.debug=1
      const urlFlag = new URLSearchParams(location.search).get('debug');
      const isOn = urlFlag === '1' || localStorage.getItem('debug') === '1';

      // Build panel lazily after DOM is ready
      const panel = document.createElement('div');
      panel.id = 'debug-panel';
      panel.innerHTML = `
        <div id="debug-panel-header">ðŸ”Ž Debug Inspector</div>
        <div id="debug-panel-controls">
          <button data-act="copy">Copy</button>
          <button data-act="clear">Clear</button>
          <button data-act="download">Download</button>
          <button data-act="perf">Mark Perf</button>
          <span style="margin-left:auto;opacity:.7">Toggle: Ctrl+Alt+D or \`</span>
        </div>
        <div id="debug-log" aria-live="polite"></div>
      `;
      document.body.appendChild(panel);
      const logEl = panel.querySelector('#debug-log');

      const ring = [];               // in-memory ring buffer
      const RING_MAX = 2000;
      const fmtTS = () => new Date().toISOString().replace('T',' ').replace('Z','');
      const safeStr = (v) => { try { return typeof v === 'string' ? v : JSON.stringify(v, (_k, val) => (val instanceof Error ? {name:val.name, message:val.message, stack:val.stack} : val)); } catch { return String(v); } };

      const push = (level, msg, payload) => {
        const item = { ts: fmtTS(), level, msg, payload };
        ring.push(item); if (ring.length > RING_MAX) ring.shift();
        const line = `[${item.ts}] ${level.toUpperCase()} â€¢ ${msg}` + (payload ? ` â†’ ${safeStr(payload)}` : '');
        if (panel.classList.contains('open')) { logEl.textContent += line + '\n'; logEl.scrollTop = logEl.scrollHeight; }
        const c = console[level] || console.log; try { c.call(console, line, payload ?? ''); } catch { console.log(line); }
      };

      const api = {
        on: isOn,
        panel,
        open() { panel.classList.add('open'); api.flush(); },
        close() { panel.classList.remove('open'); },
        toggle() { panel.classList.toggle('open'); api.flush(); },
        flush() { if (!panel.classList.contains('open')) return; logEl.textContent = ring.map(i => `[${i.ts}] ${i.level.toUpperCase()} â€¢ ${i.msg}` + (i.payload?` â†’ ${safeStr(i.payload)}`:'' )).join('\n'); logEl.scrollTop = logEl.scrollHeight; },
        log: (msg, payload) => push('log', msg, payload),
        info: (msg, payload) => push('info', msg, payload),
        warn: (msg, payload) => push('warn', msg, payload),
        error: (msg, payload) => push('error', msg, payload),
        event(topic, payload) { push('info', `event:${topic}`, payload); },
        perfMark(label) { try { performance.mark(label); push('log', `perf:mark ${label}`); } catch{} },
        perfMeasure(name, start, end) {
          try { performance.measure(name, start, end); const entry = performance.getEntriesByName(name).pop(); push('log', `perf:measure ${name}`, { durationMs: entry?.duration ?? null }); } catch(e) { push('warn', `perf:measure fail ${name}`, e); }
        },
        table(label, rows) { push('info', `table:${label}`, rows); try { console.table?.(rows); } catch {} },
      };

      // Shortcuts & buttons
      window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey && e.altKey && e.key.toLowerCase() === 'd') || e.key === '`') { e.preventDefault(); api.toggle(); }
      });
      panel.querySelector('#debug-panel-controls').addEventListener('click', (e) => {
        const act = e.target.closest('button')?.dataset?.act; if (!act) return;
        if (act === 'copy') {
          navigator.clipboard.writeText(logEl.textContent || ring.map(x=>JSON.stringify(x)).join('\n'));
        } else if (act === 'clear') {
          ring.length = 0; api.flush();
        } else if (act === 'download') {
          const blob = new Blob([logEl.textContent || ring.map(x=>JSON.stringify(x)).join('\n')], {type:'text/plain'});
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `debug-${Date.now()}.log`; a.click(); URL.revokeObjectURL(a.href);
        } else if (act === 'perf') {
          api.perfMark('manual'); setTimeout(()=>api.perfMeasure('manual-span','manual'), 120);
        }
      });

      // Global error hooks
      window.addEventListener('error', (e) => api.error('window.error', {message:e.message, stack:e.error?.stack}));
      window.addEventListener('unhandledrejection', (e) => api.error('unhandledrejection', {reason: e.reason}));

      if (isOn) api.open();
      window.__DEBUG_INSPECTOR__ = api;
      return api;
    })();

    // ================= Core: Events (simple pub-sub with logging) =================
    const Events = (() => {
      const topics = new Map();
      return {
        on(topic, handler) {
          if (!topics.has(topic)) topics.set(topic, new Set());
          topics.get(topic).add(handler);
          return () => topics.get(topic)?.delete(handler);
        },
        emit(topic, payload) {
          try { DEBUG.event(topic, payload); } catch {}
          topics.get(topic)?.forEach(h => { try { h(payload); } catch (e) { console.error(e); DEBUG.error('event.handler', { topic, error: e }); } });
        },
      };
    })();

    // ================= Core: Utils =================
    const Utils = {
      debounce(fn, ms = 250) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; },
      clamp(n, min, max) { return Math.max(min, Math.min(max, n)); },
      uuid() { return Math.random().toString(36).slice(2) + Date.now().toString(36); },
      highlight(container) { container.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block)); },
      async typeset(el) { if (window.MathJax) { try { await MathJax.typesetPromise([el]); } catch (e) { console.warn('MathJax:', e); } } },
      copyButtonForPre(pre) {
        if (pre.querySelector('.copy-btn')) return;
        pre.style.position = 'relative';
        const button = document.createElement('button');
        button.className = 'copy-btn';
        button.innerHTML = '<i class="fas fa-copy"></i> Copy';
        button.addEventListener('click', () => {
          const codeText = pre.querySelector('code')?.innerText || '';
          navigator.clipboard.writeText(codeText).then(() => { button.innerText = 'Copied!'; setTimeout(() => (button.innerHTML = '<i class="fas fa-copy"></i> Copy'), 1400); });
        });
        pre.appendChild(button);
      },
      attachCopyButtons(container) { container.querySelectorAll('pre').forEach(Utils.copyButtonForPre); },
      deepClone(obj){ return JSON.parse(JSON.stringify(obj)); },
      baseName(name='') { return String(name).split(/[\\/]/).pop()?.replace(/\.(png|jpe?g|gif|webp|bmp|svg)$/i,'') || ''; },
      approxTokens(s) { return Math.ceil(((s && typeof s === 'string') ? s.length : 0) / 4); },

      /* !!! NEW: typing effect */
      typeOnce(el, fullText, speed=55){
        if(!el) return;
        el.textContent = ''; el.classList.add('typing');
        let i = 0;
        const tick = () => {
          el.textContent = fullText.slice(0, i++);
          if(i <= fullText.length){ requestAnimationFrame(tick); }
          else { el.textContent = fullText; }
        };
        tick();
      }
    };

    // ================= Core: Storage =================
    const Storage = (() => {
      const K = {
        serverUrl: 'lmstudio.serverUrl',
        recentServers: 'lmstudio.recentServers',
        bgImage: 'lmstudio.bgImage',
        bgDim: 'lmstudio.bgDim',
        chats: 'lmstudio.chats',
        currentChatId: 'lmstudio.currentChatId',
        /* !!! NEW */
        autoReconnect: 'lmstudio.autoReconnect'
      };
      const safeGet = (k, def = null) => { try { const v = localStorage.getItem(k); return v ?? def; } catch { return def; } };
      const safeSet = (k, v) => { try { localStorage.setItem(k, v); } catch {} };
      const jsonGet = (k, def = null) => { try { const raw = localStorage.getItem(k); return raw ? JSON.parse(raw) : def; } catch { return def; } };
      const jsonSet = (k, obj) => { try { localStorage.setItem(k, JSON.stringify(obj)); } catch {} };

      return {
        K,
        getServerUrl() { return safeGet(K.serverUrl, ''); },
        setServerUrl(url) {
          safeSet(K.serverUrl, url);
          const list = jsonGet(K.recentServers, []);
          const next = [url, ...list.filter(x => x !== url)].slice(0, 5);
          jsonSet(K.recentServers, next);
        },
        getBgImage() { return safeGet(K.bgImage, ''); },
        setBgImage(dataUrl) { safeSet(K.bgImage, dataUrl); },
        clearBgImage() { try { localStorage.removeItem(K.bgImage); } catch {} },
        getBgDim() { const v = parseFloat(safeGet(K.bgDim, '')); return Number.isFinite(v) ? v : null; },
        setBgDim(v) { safeSet(K.bgDim, String(v)); },

        saveChats(chats) { jsonSet(K.chats, chats); },
        loadChats() { return jsonGet(K.chats, []); },
        saveCurrentChatId(id) { safeSet(K.currentChatId, String(id || '')); },
        loadCurrentChatId() { return safeGet(K.currentChatId, ''); },

        exportChats() { return JSON.stringify(this.loadChats(), null, 2); },
        importChats(json) {
          const data = JSON.parse(json);
          if (!Array.isArray(data)) throw new Error('Invalid chat dump: expected an array.');
          this.saveChats(data);
        },
        clearChats() {
          try { localStorage.removeItem(K.chats); } catch {}
          try { localStorage.removeItem(K.currentChatId); } catch {}
        },

        /* !!! NEW: smart auto-reconnect flag */
        getAutoReconnect() { return safeGet(K.autoReconnect, '0') === '1'; },
        setAutoReconnect(on){ safeSet(K.autoReconnect, on ? '1' : '0'); },
      };
    })();

    // ================= State (single source of truth) =================
    const State = (() => {
      const state = {
        isConnected: false,
        currentModel: '',
        serverUrl: Storage.getServerUrl() || '',
        pendingImage: null,
        pendingImageName: null,
        chats: Storage.loadChats(),
        currentChatId: Storage.loadCurrentChatId() || null,
        lastImageBaseName: null,
      };

      const persist = () => {
        const sanitized = state.chats.map(chat => ({
          id: chat.id,
          name: chat.name,
          messages: (chat.messages || []).map(m => {
            const copy = { ...m };
            if (typeof copy.content === 'string') {
              copy.content = copy.content.replace(/<img[^>]+src="data:image[^"]+"[^>]*>/gi, '[Image omitted]');
            }
            if (copy.isImage) copy.imageData = null;
            return copy;
          })
        }));
        Storage.saveChats(sanitized);
        Storage.saveCurrentChatId(state.currentChatId);
        Storage.setServerUrl(state.serverUrl);
        DEBUG.info('state.persist', { chats: state.chats.length, currentChatId: state.currentChatId });
      };

      const api = {
        get currentChat() { return state.chats.find(c => c.id === state.currentChatId) || null; },
        ensureChat() { if (!api.currentChat) api.createChat(); return api.currentChat; },
        createChat(name) {
          const chat = { id: Utils.uuid(), name: name || `Conversation ${state.chats.length + 1}`, messages: [] };
          state.chats.push(chat); state.currentChatId = chat.id; persist();
          Events.emit('state:chats', state.chats); Events.emit('state:currentChat', chat);
          DEBUG.log('state.action', { type: 'createChat', id: chat.id });
          return chat;
        },
        deleteChat(id) {
          state.chats = state.chats.filter(c => c.id !== id);
          if (state.currentChatId === id) { state.currentChatId = state.chats[0]?.id || null; }
          persist(); Events.emit('state:chats', state.chats); Events.emit('state:currentChat', api.currentChat);
          DEBUG.log('state.action', { type: 'deleteChat', id });
        },
        clearAllChats() {
          state.chats = [];
          state.currentChatId = null;
          persist();
          Events.emit('state:chats', state.chats);
          Events.emit('state:currentChat', null);
          DEBUG.warn('state.action', { type: 'clearAllChats' });
        },
        replaceChats(newChats) {
          state.chats = Array.isArray(newChats) ? newChats : [];
          state.currentChatId = state.chats[0]?.id || null;
          persist();
          Events.emit('state:chats', state.chats);
          Events.emit('state:currentChat', api.currentChat);
          DEBUG.log('state.action', { type: 'replaceChats', count: state.chats.length });
        },
        renameCurrentChatIfDefault(snippet) {
          const chat = api.currentChat; if (!chat) return;
          if (/^Conversation\s\d+/.test(chat.name) || chat.name.startsWith('Conversation ')) {
            chat.name = snippet ? `Conversation: ${snippet}...` : chat.name;
            persist(); Events.emit('state:chats', state.chats);
            DEBUG.info('state.rename.auto', { id: chat.id, name: chat.name });
          }
        },
        renameChatToImage(chatId, imageName) {
          const chat = state.chats.find(c => c.id === chatId); if (!chat) return;
          const base = Utils.baseName(imageName);
          if (!base) return;
          chat.name = base;
          persist(); Events.emit('state:chats', state.chats);
          DEBUG.info('state.rename.image', { id: chat.id, name: base });
        },
        addMessage({ content, isUser, metrics = null, isImage = false, imageData = null, text = '', chatId = null, headerLabel = null }) {
          const chat = chatId ? state.chats.find(c => c.id === chatId) : api.ensureChat();
          if (!chat) return;
          chat.messages.push({
            id: Utils.uuid(),
            content,
            isUser,
            metrics,
            isImage,
            imageData,
            text,
            ts: Date.now(),
            headerLabel: headerLabel || null,
          });
          persist();
          Events.emit('chat:messageAdded', { chatId: chat.id, message: chat.messages[chat.messages.length - 1] });
          DEBUG.info('message.add', { chatId: chat.id, isUser, isImage, len: String(content||'').length });
        },
        setConnection({ connected, model }) {
          state.isConnected = connected; if (typeof model === 'string') state.currentModel = model;
          Events.emit('state:connection', { connected, model: state.currentModel }); persist();
          DEBUG.info('connection.set', { connected, model: state.currentModel });
        },
        setServerUrl(url) { state.serverUrl = url; persist(); Events.emit('state:serverUrl', url); },
        setModel(model) { state.currentModel = model; Events.emit('state:model', model); persist(); },
        setPendingImage(dataUrl, fileName = null) { state.pendingImage = dataUrl; state.pendingImageName = fileName; Events.emit('state:pendingImage', dataUrl); },
        setLastImageBaseName(name) { state.lastImageBaseName = Utils.baseName(name); },
        selectChat(id) { state.currentChatId = id; persist(); Events.emit('state:currentChat', api.currentChat); DEBUG.log('state.action', { type: 'selectChat', id }); },
        get snapshot() { return JSON.parse(JSON.stringify(state)); },
      };
      return api;
    })();

    // ================= Services: Background =================
    const BackgroundService = (() => {
      const bgLayer = document.getElementById('bg-layer');
      function applyFromStorage() {
        const dataUrl = Storage.getBgImage();
        const dim = Storage.getBgDim();
        if (dataUrl) { bgLayer.style.backgroundImage = `url('${dataUrl}')`; document.body.style.backgroundColor = 'transparent'; }
        if (dim != null) document.documentElement.style.setProperty('--dim-amount', String(Utils.clamp(dim, 0, 0.8)));
      }
      function setFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = e => { const dataUrl = e.target.result; Storage.setBgImage(dataUrl); bgLayer.style.backgroundImage = `url('${dataUrl}')`; DEBUG.info('bg.set', { name: file.name, size: file.size }); };
        reader.readAsDataURL(file);
      }
      function clear() { Storage.clearBgImage(); bgLayer.style.backgroundImage = ''; DEBUG.log('bg.clear'); }
      function setDim(v) { const vv = Utils.clamp(parseFloat(v) || 0, 0, 0.8); Storage.setBgDim(vv); document.documentElement.style.setProperty('--dim-amount', String(vv)); DEBUG.info('bg.dim', { value: vv }); }
      return { applyFromStorage, setFile, clear, setDim };
    })();

    // ================= Services: LM Studio API =================
    const LMStudioAPI = (() => {
      /*
        Role: HTTP wrapper for LM Studio endpoints
        Endpoints: /v1/models, /v1/model/eject (POST), /v1/chat/completions (POST with stream)
        Perf Marks: 'models:*', 'chat:*'
      */
      async function listModels(serverUrl) {
        DEBUG.perfMark('models:start');
        DEBUG.info('api.listModels', { serverUrl });
        const res = await fetch(`${serverUrl}/v1/models`);
        DEBUG.perfMeasure('models:latency','models:start');
        DEBUG.info('api.listModels.res', { ok: res.ok, status: res.status });
        if (!res.ok) throw new Error('Failed to list models');
        return res.json();
      }
      async function eject(serverUrl, model) {
        try {
          DEBUG.info('api.eject', { model });
          await fetch(`${serverUrl}/v1/model/eject`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model }) });
        } catch (e) { console.warn('Eject error:', e); DEBUG.warn('api.eject.fail', { error: String(e) }); }
      }
      // UPDATED: include llama.cpp fields like n_keep, and safer defaults
      async function* streamChat({ serverUrl, model, messages, temperature = 0.7, max_tokens = 512 }) {
        DEBUG.perfMark('chat:start');
        DEBUG.info('api.chat.begin', { model, msgCount: messages?.length });
        const body = {
          model,
          messages,
          temperature,
          max_tokens,
          stream: true,
          // llama.cpp extras â€” tune as needed
          n_keep: 1024,
          repeat_penalty: 1.1,
          top_k: 40,
          top_p: 0.95
        };
        const res = await fetch(`${serverUrl}/v1/chat/completions`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (!res.ok || !res.body) { DEBUG.error('api.chat.streamStartFail', { status: res.status }); throw new Error('Streaming failed'); }
        const reader = res.body.getReader(); const decoder = new TextDecoder();
        while (true) {
          const { value, done } = await reader.read(); if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n').filter(line => line.trim() !== '');
          for (const line of lines) {
            if (line.startsWith('data:')) {
              const dataStr = line.slice(5).trim();
              if (dataStr === '[DONE]') { DEBUG.perfMeasure('chat:latency','chat:start'); return; }
              try {
                const parsed = JSON.parse(dataStr);
                const delta = parsed.choices?.[0]?.delta?.content;
                if (delta) yield delta;
              } catch (e) { console.warn('parse', e); DEBUG.warn('api.chat.parse', { err: String(e) }); }
            }
          }
        }
        DEBUG.perfMeasure('chat:latency','chat:start');
      }
      return { listModels, eject, streamChat };
    })();

    // ================= Services: Health (optional ping) =================
    const Health = (() => {
      async function ping() {
        const { serverUrl } = State.snapshot;
        if (!serverUrl) return false;
        try {
          const r = await fetch(`${serverUrl}/v1/models`, { method: 'GET' });
          return r.ok;
        } catch {
          return false;
        }
      }
      return { ping };
    })();

    // ================= UI: Header =================
    const Header = (() => {
      const els = {
        serverUrl: document.getElementById('server-url'),
        modelSelect: document.getElementById('model-select'),
        bgPickButton: document.getElementById('bg-pick-button'),
        bgUpload: document.getElementById('bg-upload'),
        connectButton: document.getElementById('connect-button'),
        status: document.getElementById('connection-status'),

        exportBtn: document.getElementById('export-chats'),
        importBtn: document.getElementById('import-chats'),
        clearBtn:  document.getElementById('clear-chats'),
        importFile:document.getElementById('import-file'),

        /* !!! NEW */
        banner: document.getElementById('header-banner'),
      };

      let longPressTimer = null;
      /* !!! NEW: manual disconnect guard */
      let lastDisconnectManual = false;

      function setStatus(text, ok) {
        els.status.textContent = text;
        els.status.style.color = ok ? 'var(--accent-color)' : '#f44336';
        els.connectButton.innerHTML = ok ? '<i class="fas fa-link"></i> Disconnect' : '<i class="fas fa-plug"></i> Connect';
        els.serverUrl.disabled = ok; Events.emit('ui:connectionControls', { enabled: ok });
      }

      function populateModels(data) {
        const list = data?.data || [];
        els.modelSelect.innerHTML = '';
        for (const m of list) {
          const opt = document.createElement('option');
          opt.value = m.id; opt.textContent = m.id;
          els.modelSelect.appendChild(opt);
        }
        els.modelSelect.disabled = list.length === 0;
        if (list.length > 0) els.modelSelect.selectedIndex = 0;
        State.setModel(els.modelSelect.value || '');
      }

      /* !!! NEW: shared connect func */
      async function tryConnect(serverUrl){
        DEBUG.log('ui.connect.try', { serverUrl });
        if (!serverUrl) { setStatus('Please enter a valid server address', false); return false; }
        try {
          setStatus('Connecting...', false);
          const data = await LMStudioAPI.listModels(serverUrl);
          State.setServerUrl(serverUrl);
          populateModels(data);
          State.setConnection({ connected: true });
          setStatus('Connected', true);
          Events.emit('network:connected', { serverUrl });
          Storage.setAutoReconnect(true); // enable smart auto-reconnect after first success
          DEBUG.info('ui.connect.success', { modelCount: (data?.data||[]).length });
          DEBUG.table('models', (data?.data||[]).map(m => ({ id: m.id })));
          return true;
        } catch (e) {
          console.error(e);
          setStatus('Failed to connect', false);
          DEBUG.error('ui.connect.fail', { message: String(e) });
          return false;
        }
      }

      /* !!! NEW: Smart Reconnect (exponential backoff) */
      const Reconnect = (() => {
        let timer = null;
        let backoff = 2000;       // 2s start
        const MAX = 30000;        // 30s cap

        function schedule(reason=''){
          clear();
          const { serverUrl, isConnected } = State.snapshot;
          // Conditions:
          // 1) user has previously connected (flag true)
          // 2) currently disconnected
          // 3) URL present
          // 4) last action wasn't manual disconnect
          if (!Storage.getAutoReconnect() || isConnected || !serverUrl || lastDisconnectManual) return;

          DEBUG.info('reconnect.schedule', { afterMs: backoff, reason, urlPresent: !!serverUrl });
          timer = setTimeout(async () => {
            const ok = await tryConnect(serverUrl);
            if (ok) { backoff = 2000; }
            else { backoff = Math.min(backoff * 2, MAX); schedule('retry'); }
          }, backoff);
        }
        function clear(){ if (timer) { clearTimeout(timer); timer = null; } }
        return { schedule, clear, reset: () => { backoff = 2000; } };
      })();

      function attach() {
        const saved = State.snapshot.serverUrl || Storage.getServerUrl(); if (saved) els.serverUrl.value = saved;

        // Banner typing once (desktop only)
        if (els.banner && window.matchMedia('(min-width: 769px)').matches) {
          Utils.typeOnce(els.banner, 'built by Brian Won', 55);
        }

        els.serverUrl.addEventListener('input', Utils.debounce(() => {
          State.setServerUrl(els.serverUrl.value.trim());
          DEBUG.log('ui.serverUrl.input', { value: els.serverUrl.value.trim() });
        }, 200));

        // Background controls
        els.bgPickButton.addEventListener('mousedown', () => {
          longPressTimer = setTimeout(() => {
            const choice = window.prompt('Background: type "pick" to choose, "clear" to remove, or a number (0â€“0.8) to set dim.');
            if (!choice) return;
            if (choice.toLowerCase() === 'clear') BackgroundService.clear();
            else if (choice.toLowerCase() === 'pick') els.bgUpload.click();
            else { const v = parseFloat(choice); if (!isNaN(v)) BackgroundService.setDim(v); }
          }, 500);
        });
        ['mouseup','mouseleave'].forEach(ev => els.bgPickButton.addEventListener(ev, () => clearTimeout(longPressTimer)));
        els.bgPickButton.addEventListener('click', () => els.bgUpload.click());
        els.bgUpload.addEventListener('change', () => { const f = els.bgUpload.files?.[0]; if (f) BackgroundService.setFile(f); els.bgUpload.value = ''; });

        // Connect / Disconnect
        els.connectButton.addEventListener('click', async () => {
          DEBUG.log('ui.connect.click', {});
          const { isConnected } = State.snapshot;
          if (isConnected) {
            lastDisconnectManual = true;               // manual disconnect
            State.setConnection({ connected: false });
            setStatus('Disconnected', false);
            Events.emit('network:disconnected', { manual: true });
            return;
          }
          const serverUrl = els.serverUrl.value.trim();
          lastDisconnectManual = false;
          await tryConnect(serverUrl);
        });

        // Model switching
        els.modelSelect.addEventListener('change', async (e) => {
          const newModel = e.target.value; const { serverUrl, currentModel } = State.snapshot;
          DEBUG.log('ui.model.change', { from: currentModel, to: newModel });
          if (currentModel && currentModel !== newModel) await LMStudioAPI.eject(serverUrl, currentModel);
          State.setModel(newModel);
        });

        // Export / Import / Clear
        els.exportBtn?.addEventListener('click', () => {
          const blob = new Blob([Storage.exportChats()], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `lmstudio-chats-${new Date().toISOString().slice(0,19)}.json`;
          a.click();
          URL.revokeObjectURL(a.href);
          DEBUG.log('ui.export');
        });

        els.importBtn?.addEventListener('click', () => els.importFile?.click());
        els.importFile?.addEventListener('change', async () => {
          const f = els.importFile.files?.[0];
          if (!f) return;
          try {
            const text = await f.text();
            Storage.importChats(text);
            const chats = Storage.loadChats();
            State.replaceChats(chats);
            alert('Chats imported.');
            DEBUG.log('ui.import', { count: chats.length });
          } catch (e) {
            console.error(e);
            alert('Import failed: invalid JSON or structure.');
            DEBUG.error('ui.import.fail', { error: String(e) });
          } finally {
            els.importFile.value = '';
          }
        });

        els.clearBtn?.addEventListener('click', () => {
          if (!confirm('Delete all saved chats? This cannot be undone.')) return;
          Storage.clearChats();
          State.clearAllChats();
          DEBUG.warn('ui.clearAll');
        });

        // Connection state reflect
        Events.on('state:connection', ({ connected }) => { setStatus(connected ? 'Connected' : 'Disconnected', connected); });

        /* NEW: net events hook */
        Events.on('network:connected', () => {
          lastDisconnectManual = false;
          Reconnect.clear();
          Reconnect.reset();
        });
        Events.on('network:disconnected', (info) => {
          if (info?.manual) {
            Storage.setAutoReconnect(false);   // user chose to stay offline
            Reconnect.clear();
          } else {
            Reconnect.schedule('lost');
          }
        });

        // On-load gentle auto-connect (only if user connected before & URL present)
        const savedUrl = (State.snapshot.serverUrl || Storage.getServerUrl() || '').trim();
        if (Storage.getAutoReconnect() && savedUrl) {
          tryConnect(savedUrl).then(ok => { if (!ok) Reconnect.schedule('onload'); });
        }
      }

      return { attach, setStatus };
    })();

    // ================= UI: Sidebar (chat list) =================
    const Sidebar = (() => {
      const els = {
        list: document.getElementById('chat-list'),
        newChat: document.getElementById('new-chat-button'),
        toggle: document.getElementById('toggle-sidebar'),
        sidebar: document.getElementById('chat-sidebar'),
        contextMenu: document.getElementById('context-menu')
      };

      function render(chats, currentId) {
        els.list.innerHTML = '';
        for (const c of chats) {
          const li = document.createElement('li');
          li.textContent = c.name; li.dataset.chatId = c.id; if (c.id === currentId) li.classList.add('active');
          li.addEventListener('click', () => State.selectChat(c.id));
          li.addEventListener('contextmenu', (e) => { e.preventDefault(); showContextMenu(e.pageX, e.pageY, c.id); });
          els.list.appendChild(li);
        }
        DEBUG.log('sidebar.render', { count: State.snapshot.chats.length, current: State.snapshot.currentChatId });
      }

      function showContextMenu(x, y, chatId) {
        const m = els.contextMenu;

        // Prepare & measure
        m.style.display = 'block';
        m.style.visibility = 'hidden';
        const w = m.offsetWidth || 160;
        const h = m.offsetHeight || 40;

        // Clamp within viewport
        const margin = 8;
        const nx = Math.min(x, window.innerWidth  - w - margin);
        const ny = Math.min(y, window.innerHeight - h - margin);

        // Place and show
        m.style.left = nx + 'px';
        m.style.top  = ny + 'px';
        m.style.visibility = 'visible';

        m.onclick = async (e) => {
          e.stopPropagation();
          State.deleteChat(chatId);
          const ok = await Health.ping();
          if (!ok) Header.setStatus('Connected (server did not respond to ping)', false);
          hideContextMenu();
          DEBUG.warn('ui.chat.delete', { id: chatId });
        };
      }
      function hideContextMenu() { els.contextMenu.style.display = 'none'; els.contextMenu.style.visibility = 'hidden'; }

      function bind() {
        els.newChat.addEventListener('click', async () => {
          State.createChat();
          const ok = await Health.ping();
          if (!ok) Header.setStatus('Connected (server did not respond to ping)', false);
          DEBUG.log('ui.chat.new');
        });
        els.toggle.addEventListener('click', () => els.sidebar.classList.toggle('collapsed'));

        // Mobile off-canvas controls
        const mobileBtn = document.getElementById('mobile-menu-button');
        const backdrop  = document.getElementById('sidebar-backdrop');

        const open = () => {
          els.sidebar.classList.add('open');
          backdrop?.classList.add('show');
          document.body.style.overflow = 'hidden';
          DEBUG.log('ui.sidebar.mobile', { action: 'open' });
        };
        const close = () => {
          els.sidebar.classList.remove('open');
          backdrop?.classList.remove('show');
          document.body.style.overflow = '';
          DEBUG.log('ui.sidebar.mobile', { action: 'close' });
        };

        mobileBtn?.addEventListener('click', open);
        backdrop?.addEventListener('click', close);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });

        const mq = window.matchMedia('(min-width: 769px)');
        if (mq.addEventListener) mq.addEventListener('change', () => { if (mq.matches) close(); });
        else mq.onchange = () => { if (mq.matches) close(); };

        const refresh = () => render(State.snapshot.chats, State.snapshot.currentChatId);
        Events.on('state:chats', refresh); Events.on('state:currentChat', refresh);
        refresh();

        document.addEventListener('click', () => hideContextMenu());
        window.addEventListener('scroll', hideContextMenu, { passive: true });
        window.addEventListener('resize', hideContextMenu);
      }
      return { bind };
    })();

    // ================= UI: ChatView (append-only streaming safe) =================
    const ChatView = (() => {
      const container = document.getElementById('chat-container');
      let liveStreamEl = null;

      function messageHtml(msg, model) {
        const { isUser, content } = msg;
        const wrapper = document.createElement('div');
        wrapper.classList.add('message', isUser ? 'user-message' : 'assistant-message');

        const header = document.createElement('div');
        header.className = 'message-header';
        header.textContent = isUser ? 'You' : (msg.headerLabel || 'Assistant');
        wrapper.appendChild(header);

        if (!isUser && model) {
          const m = document.createElement('div');
          m.className = 'message-model';
          m.textContent = model;
          wrapper.appendChild(m);
        }

        const meta = document.createElement('div');
        meta.className = 'message-metrics';
        const when = new Date(msg.ts || Date.now()).toLocaleString();
        meta.textContent = when;
        wrapper.appendChild(meta);

        const body = document.createElement('div');
        body.className = 'message-content';
        body.innerHTML = marked.parse(content || '');
        wrapper.appendChild(body);

        return { wrapper, body };
      }

      function appendMessage(msg) {
        const { wrapper } = messageHtml(msg, !msg.isUser ? State.snapshot.currentModel : '');
        container.appendChild(wrapper);
        Utils.highlight(wrapper); Utils.attachCopyButtons(wrapper); Utils.typeset(wrapper);
        container.scrollTop = container.scrollHeight;
      }

      function renderChat(chat) {
        container.innerHTML = '';
        if (!chat) return;
        for (const msg of chat.messages) appendMessage(msg);
        container.scrollTop = container.scrollHeight;
      }

      function addStreamingAssistantMessage(headerLabel=null) {
        const shell = document.createElement('div');
        shell.className = 'message assistant-message';
        shell.innerHTML = `
          <div class="message-header">${headerLabel || 'Assistant'}</div>
          <div class="message-model">${State.snapshot.currentModel || ''}</div>
          <div class="message-metrics">${new Date().toLocaleString()}</div>
          <div class="message-content"><span class="loading-dots">Loading</span></div>
        `;
        container.appendChild(shell);
        container.scrollTop = container.scrollHeight;
        return {
          body: shell.querySelector('.message-content'),
          discard() { shell.remove(); }
        };
      }

      function updateStreaming(targetBody, text) {
        targetBody.innerHTML = marked.parse(text);
        const parent = targetBody.parentElement;
        Utils.highlight(parent); Utils.attachCopyButtons(parent); Utils.typeset(parent);
        if ((text?.length||0) % 500 < 10) DEBUG.log('ui.stream.chunk', { chars: text.length });
        container.scrollTop = container.scrollHeight;
      }

      function bind() {
        Events.on('state:currentChat', renderChat);
        Events.on('chat:messageAdded', ({ chatId, message }) => {
          if (State.snapshot.currentChatId !== chatId) return;
          appendMessage(message);
        });
        renderChat(State.snapshot.currentChat);
      }
      return { bind, addStreamingAssistantMessage, updateStreaming };
    })();

    // ========= NEW: history builder with soft token budget =========
    function buildHistoryWithCap({ chat, hasImage, ctxSoftLimit = 3500 }) {
      const SYS = hasImage
        ? { role: 'system', content: 'You are an AI assistant that analyzes images.' }
        : { role: 'system', content: 'You are an intelligent assistant. You always provide well-reasoned answers that are both correct and helpful.' };

      let budget = ctxSoftLimit - Utils.approxTokens(SYS.content);
      const reversed = [...(chat?.messages || [])].reverse();
      const kept = [];

      for (const m of reversed) {
        let payload;
        if (m.isImage && m.imageData) {
          const text = m.text || "What's in this image?";
          const label = m.headerLabel ? `[image:${m.headerLabel}] ` : '[image] ';
          payload = { role: m.isUser ? 'user' : 'assistant', content: label + text };
        } else {
          payload = { role: m.isUser ? 'user' : 'assistant', content: m.content || '' };
        }
        const cost = Utils.approxTokens(payload.content);
        if (cost > budget) break;
        kept.push(payload);
        budget -= cost;
      }
      kept.reverse();
      return [SYS, ...kept];
    }

    // ================= UI: InputBar =================
    const InputBar = (() => {
      const els = {
        dropZone: document.getElementById('input-container'),
        uploadBtn: document.getElementById('upload-button'),
        file: document.getElementById('image-upload'),
        preview: document.getElementById('image-preview'),
        input: document.getElementById('user-input'),
        send: document.getElementById('send-button')
      };

      function setEnabled(yes) { els.input.disabled = !yes; els.send.disabled = !yes; }
      function showPendingImage(dataURL) {
        els.preview.innerHTML = `<img src="${dataURL}" style="max-width:100%; border-radius: var(--border-radius);" />`;
        els.preview.style.display = 'block';
      }
      function clearPendingPreview() { els.preview.innerHTML = ''; els.preview.style.display = 'none'; }

      async function handleImageFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const dataURL = await new Promise((resolve, reject) => {
          const r = new FileReader(); r.onload = e => resolve(e.target.result); r.onerror = reject; r.readAsDataURL(file);
        });
        State.setPendingImage(dataURL, file.name || null);
        State.setLastImageBaseName(file.name || null);
        showPendingImage(dataURL); els.input.focus();
        DEBUG.info('ui.input.image.set', { name: file?.name, size: file?.size });
      }

      async function handleTransferItems(dt) {
        if (!dt) return;
        if (dt.files && dt.files.length) {
          for (const f of dt.files) { if (f.type?.startsWith('image/')) { await handleImageFile(f); return; } }
        }
        if (dt.items && dt.items.length) {
          for (const it of dt.items) {
            if (it.kind === 'file' && it.type.startsWith('image/')) {
              const f = it.getAsFile(); if (f) { await handleImageFile(f); return; }
            }
          }
        }
        const url = dt.getData && (dt.getData('text/uri-list') || dt.getData('text/plain'));
        if (url && /^https?:\/\//i.test(url) && /\.(png|jpe?g|gif|webp|bmp|svg)(\?|#|$)/i.test(url)) {
          State.setPendingImage(url, url);
          State.setLastImageBaseName(url);
          showPendingImage(url); els.input.focus();
          DEBUG.info('ui.input.image.url', { url });
        }
      }

      function bind() {
        // Buttons & file input
        els.uploadBtn.addEventListener('click', () => els.file.click());
        els.file.addEventListener('change', () => { const f = els.file.files?.[0]; if (f) handleImageFile(f); els.file.value = ''; });

        // Paste & DnD
        els.input.addEventListener('paste', async (e) => {
          const dt = e.clipboardData; if (!dt) return;
          const hasImg = Array.from(dt.items || []).some(i => i.kind === 'file' && i.type.startsWith('image/'));
          if (hasImg) { e.preventDefault(); await handleTransferItems(dt); DEBUG.info('ui.input.paste.image'); }
        });
        document.addEventListener('paste', async (e) => {
          if (document.activeElement !== els.input) {
            const dt = e.clipboardData; if (!dt) return;
            const hasImg = Array.from(dt.items || []).some(i => i.kind === 'file' && i.type.startsWith('image/'));
            if (hasImg) { e.preventDefault(); await handleTransferItems(dt); DEBUG.info('ui.input.paste.image.outside'); }
          }
        });
        ;['dragenter','dragover','dragleave','drop'].forEach(evt => {
          els.dropZone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); });
        });
        els.dropZone.addEventListener('dragenter', () => els.dropZone.classList.add('drop-hover'));
        els.dropZone.addEventListener('dragover',  () => els.dropZone.classList.add('drop-hover'));
        els.dropZone.addEventListener('dragleave', () => els.dropZone.classList.remove('drop-hover'));
        els.dropZone.addEventListener('drop', async (e) => { els.dropZone.classList.remove('drop-hover'); const dt = e.dataTransfer; await handleTransferItems(dt); DEBUG.info('ui.input.drop.image'); });

        // Enable/disable with connection
        Events.on('ui:connectionControls', ({ enabled }) => setEnabled(enabled));
        setEnabled(false);
      }

      function getMessageAndMaybeImage() {
        const text = els.input.value.trim();
        const img = State.snapshot.pendingImage;
        const imgName = State.snapshot.pendingImageName;
        if (!text && !img) return null;

        const targetChatId = State.snapshot.currentChatId;

        if (img) {
          State.addMessage({ content: `<img src="${img}" style="max-width:100%; border-radius: var(--border-radius);" />`, isUser: true, chatId: targetChatId });
          State.addMessage({ content: text || "What's in this image?", isUser: true, isImage: true, imageData: img, text: text || '', chatId: targetChatId });
          if (imgName) State.renameChatToImage(targetChatId, imgName);
          State.setPendingImage(null, null); clearPendingPreview(); els.input.value = '';
          return { kind: 'image', text: text || "What's in this image?", data: img, chatId: targetChatId, headerLabel: Utils.baseName(imgName) || null };
        } else {
          State.addMessage({ content: text, isUser: true, chatId: targetChatId });
          els.input.value = '';
          return { kind: 'text', text, chatId: targetChatId, headerLabel: null };
        }
      }

      function focus() { els.input.focus(); }

      return { bind, getMessageAndMaybeImage, focus };
    })();

    // ================= App Controller =================
    const AppController = (() => {
      async function onSend() {
        const { serverUrl, currentModel, isConnected } = State.snapshot;
        DEBUG.log('onSend.begin', { isConnected, hasModel: !!currentModel });
        if (!isConnected) { Header.setStatus('Disconnected', false); alert('Connect to the LM Studio server first.'); return; }
        if (!serverUrl) { alert('Missing server URL.'); return; }
        if (!currentModel) { alert('Pick a model before sending.'); return; }

        const req = InputBar.getMessageAndMaybeImage();
        if (!req) return;

        const targetChatId = req.chatId;
        const headerLabel = req.headerLabel;

        let stream = null;
        if (State.snapshot.currentChatId === targetChatId) {
          stream = ChatView.addStreamingAssistantMessage(headerLabel);
        }
        let acc = '';

        const chatForHistory = State.snapshot.chats.find(c => c.id === targetChatId) || State.ensureChat();
        const hasImage = chatForHistory.messages.some(m => m.isImage);
        const history = buildHistoryWithCap({ chat: chatForHistory, hasImage, ctxSoftLimit: 3500 });

        try {
          for await (const delta of LMStudioAPI.streamChat({ serverUrl, model: currentModel, messages: history })) {
            acc += delta;
            if (stream) ChatView.updateStreaming(stream.body, acc);
          }
          if (stream) stream.discard();
          State.addMessage({ content: acc, isUser: false, chatId: targetChatId, headerLabel });
          if (!headerLabel) State.renameCurrentChatIfDefault(acc.split(' ').slice(0, 7).join(' '));
          DEBUG.info('onSend.done', { size: acc.length });
        } catch (e) {
          console.error(e);
          if (stream) stream.discard();
          State.addMessage({ content: 'Send failed (connection kept). Check server URL, CORS, model, and try again.', isUser: false, chatId: targetChatId, headerLabel });
          DEBUG.error('onSend.error', { error: String(e) });
        } finally {
          InputBar.focus();
        }
      }

      function init() {
        BackgroundService.applyFromStorage();
        Header.attach(); Sidebar.bind(); ChatView.bind(); InputBar.bind();
        if (!State.snapshot.currentChatId || !State.snapshot.chats.length) State.createChat();
        const urlInput = document.getElementById('server-url'); urlInput.focus();

        // Bind send controls
        const sendBtn = document.getElementById('send-button');
        const input = document.getElementById('user-input');
        sendBtn.addEventListener('click', onSend);
        input.addEventListener('keypress', (e) => { if (e.key === 'Enter') onSend(); });
      }

      return { init };
    })();

    // ================= Boot =================
    AppController.init();
  </script>
</body>
</html>
